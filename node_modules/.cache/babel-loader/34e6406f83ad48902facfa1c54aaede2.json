{"ast":null,"code":"import { alertFailure, alertSuccess } from '../../store/actions/alert';\nimport { ConnectorNames } from '../../constants/connectors';\nimport { userActions } from '../constants/user';\nimport { walletActions } from '../constants/wallet';\nimport { alertActions } from '../constants/alert';\nimport { BaseRequest } from '../../request/Request';\nimport { getWeb3Instance } from '../../services/web3';\nimport { ethers } from 'ethers';\nconst MESSAGE_INVESTOR_SIGNATURE = process.env.REACT_APP_MESSAGE_INVESTOR_SIGNATURE || \"\";\n\nconst getMessageParams = () => {\n  const msgSignature = MESSAGE_INVESTOR_SIGNATURE;\n  return [{\n    type: 'string',\n    // Any valid solidity type\n    name: 'Message',\n    // Any string label you want\n    value: msgSignature // The value to sign\n\n  }];\n};\n\nexport const getParamsWithConnector = connectedAccount => ({\n  [ConnectorNames.BSC]: {\n    method: 'eth_sign',\n    params: [connectedAccount, MESSAGE_INVESTOR_SIGNATURE]\n  },\n  [ConnectorNames.WalletConnect]: {\n    method: 'eth_sign',\n    params: [connectedAccount, MESSAGE_INVESTOR_SIGNATURE]\n  },\n  [ConnectorNames.WalletLinkConnect]: {\n    method: 'eth_sign',\n    params: [connectedAccount, MESSAGE_INVESTOR_SIGNATURE]\n  },\n  [ConnectorNames.Fortmatic]: {\n    method: 'eth_signTypedData',\n    params: [getMessageParams(), connectedAccount]\n  },\n  [ConnectorNames.MetaMask]: {\n    method: 'eth_signTypedData',\n    params: [getMessageParams(), connectedAccount]\n  }\n});\n\nconst dispatchErrorWithMsg = (dispatch, action, msg) => {\n  dispatch({\n    type: action,\n    payload: msg\n  });\n};\n\nconst getCurrentAccount = async () => {\n  const web3Instance = getWeb3Instance();\n  const accounts = await (web3Instance === null || web3Instance === void 0 ? void 0 : web3Instance.eth.getAccounts());\n\n  if (accounts && accounts.length !== 0) {\n    return accounts[0];\n  }\n\n  return undefined;\n};\n\nexport const logout = (isInvestor = false) => {\n  isInvestor ? localStorage.removeItem(\"investor_access_token\") : localStorage.removeItem(\"access_token\");\n  return {\n    type: !isInvestor ? userActions.USER_LOGOUT : userActions.INVESTOR_LOGOUT\n  };\n};\nexport const resetUserState = (isInvestor = false) => {\n  return {\n    type: !isInvestor ? userActions.USER_PURGE : userActions.INVESTOR_PURGE\n  };\n};\nexport const clearUserProfileUpdate = () => {\n  return {\n    type: userActions.USER_PROFILE_UPDATE_CLEAR_ERROR\n  };\n};\nexport const login = (connectedAccount, library) => {\n  return async (dispatch, getState) => {\n    try {\n      dispatch({\n        type: userActions.INVESTOR_LOGIN_LOADING\n      });\n      const baseRequest = new BaseRequest();\n      const connector = getState().connector.data;\n      const paramsWithConnector = getParamsWithConnector(connectedAccount)[connector];\n\n      if (connectedAccount && library && paramsWithConnector) {\n        const provider = library.provider;\n\n        if (connector !== ConnectorNames.WalletConnect) {\n          const res = await provider.sendAsync({\n            method: paramsWithConnector.method,\n            params: paramsWithConnector.params\n          }, async function (err, result) {\n            if (err || result.error) {\n              const errMsg = err.message || err.error || result.error.message;\n              console.log('Error when signing message: ', errMsg);\n              dispatchErrorWithMsg(dispatch, userActions.INVESTOR_LOGIN_FAILURE, errMsg);\n            } else {\n              console.log(result.result);\n              const response = await baseRequest.post(`/user/login`, {\n                signature: result.result,\n                wallet_address: connectedAccount\n              });\n              const resObj = await response.json();\n\n              if (resObj.status && resObj.status === 200 && resObj.data) {\n                const {\n                  token,\n                  user\n                } = resObj.data;\n                localStorage.setItem('investor_access_token', token.token);\n                dispatch({\n                  type: walletActions.WALLET_CONNECT_LAYER2_SUCCESS\n                });\n                dispatch({\n                  type: userActions.INVESTOR_LOGIN_SUCCESS,\n                  payload: user\n                });\n              }\n\n              if (resObj.status && resObj.status !== 200) {\n                if (resObj.status == 404) {\n                  // redirect to register page\n                  dispatch(alertFailure(resObj.message));\n                  dispatchErrorWithMsg(dispatch, userActions.INVESTOR_LOGIN_FAILURE, '');\n                } else {\n                  // show error\n                  console.log('RESPONSE Login: ', resObj);\n                  dispatch(alertFailure(resObj.message));\n                  dispatchErrorWithMsg(dispatch, userActions.INVESTOR_LOGIN_FAILURE, '');\n                }\n              }\n            }\n          });\n        } else {\n          var rawMessage = MESSAGE_INVESTOR_SIGNATURE;\n          var rawMessageLength = new Blob([rawMessage]).size;\n          var message = ethers.utils.toUtf8Bytes(\"\\x19Ethereum Signed Message:\\n\" + rawMessageLength + rawMessage);\n          var messageHash = ethers.utils.keccak256(message);\n          var params = [connectedAccount, messageHash];\n          await library.provider.enable();\n          var signature = await library.provider.wc.signMessage(params);\n          console.log(signature);\n        }\n      }\n    } catch (error) {\n      console.log('ERROR Login: ', error);\n      dispatch(alertFailure(error.message));\n      dispatchErrorWithMsg(dispatch, userActions.INVESTOR_LOGIN_FAILURE, '');\n    }\n  };\n};\nexport const register = ({\n  email,\n  address: connectedAccount,\n  library\n}) => {\n  return async (dispatch, getState) => {\n    dispatch({\n      type: userActions.INVESTOR_REGISTER_LOADING\n    });\n\n    try {\n      const baseRequest = new BaseRequest();\n      const connector = getState().connector.data;\n      const paramsWithConnector = getParamsWithConnector(connectedAccount)[connector];\n\n      if (connectedAccount && library && paramsWithConnector) {\n        const provider = library.provider;\n        provider && (await provider.sendAsync({\n          method: paramsWithConnector.method,\n          params: paramsWithConnector.params\n        }, async function (err, result) {\n          if (err || result.error) {\n            const errMsg = err.message || err.error || result.error.message;\n            dispatchErrorWithMsg(dispatch, userActions.INVESTOR_REGISTER_FAILURE, errMsg);\n            return;\n          }\n\n          const response = await baseRequest.post(`/user/register/`, {\n            email,\n            wallet_address: connectedAccount,\n            signature: result.result\n          });\n          const resObj = await response.json();\n\n          if (resObj.status && resObj.status === 200) {\n            if (resObj.data) {\n              const {\n                token,\n                user\n              } = resObj.data;\n              localStorage.setItem('investor_access_token', token.token);\n              dispatch({\n                type: walletActions.WALLET_CONNECT_LAYER2_SUCCESS\n              });\n              dispatch({\n                type: alertActions.SUCCESS_MESSAGE,\n                payload: 'Register Account Successful'\n              });\n              dispatch({\n                type: userActions.INVESTOR_REGISTER_SUCCESS,\n                payload: user\n              });\n              dispatch({\n                type: userActions.INVESTOR_LOGIN_SUCCESS,\n                payload: user\n              });\n            } else {\n              dispatch({\n                type: alertActions.SUCCESS_MESSAGE,\n                payload: resObj.message\n              });\n              dispatch({\n                type: userActions.INVESTOR_REGISTER_SUCCESS,\n                payload: resObj.message\n              });\n            }\n          }\n\n          if (resObj.status && resObj.status !== 200) {\n            console.log('RESPONSE Register: ', resObj);\n            dispatch(alertFailure(resObj.message));\n            dispatchErrorWithMsg(dispatch, userActions.INVESTOR_REGISTER_FAILURE, '');\n          }\n        }));\n      }\n    } catch (error) {\n      console.log('ERROR Register: ', error);\n      dispatch(alertFailure(error.message));\n      dispatchErrorWithMsg(dispatch, userActions.INVESTOR_REGISTER_FAILURE, '');\n    }\n  };\n};\nexport const connectWallet = () => {\n  return async dispatch => {\n    dispatch({\n      type: userActions.USER_CONNECT_WALLET_LOADING\n    });\n\n    try {\n      const windowObj = window;\n      const {\n        ethereum\n      } = windowObj;\n      const accounts = await ethereum.request({\n        method: 'eth_requestAccounts'\n      });\n      const loginUser = accounts.length ? accounts[0] : '';\n\n      if (loginUser) {\n        dispatch({\n          type: userActions.USER_CONNECT_WALLET_SUCCESS,\n          payload: loginUser\n        });\n      } else {\n        dispatch(logout());\n      }\n    } catch (error) {\n      dispatch({\n        type: userActions.USER_CONNECT_WALLET_FAILURE,\n        payload: error\n      });\n    }\n  };\n};\nexport const getUserDetail = () => {\n  return async dispatch => {\n    dispatch({\n      type: userActions.USER_PROFILE_LOADING\n    });\n\n    try {\n      const baseRequest = new BaseRequest();\n      const response = await baseRequest.get('/user/profile');\n      const resObj = await response.json();\n\n      if (resObj.status && resObj.status === 200) {\n        dispatch({\n          type: userActions.USER_PROFILE_SUCCESS,\n          payload: resObj.data.user\n        });\n      } else {\n        dispatch({\n          type: userActions.USER_PROFILE_FAILURE,\n          payload: resObj.message\n        });\n      }\n    } catch (error) {\n      dispatch({\n        type: userActions.USER_PROFILE_FAILURE,\n        payload: error\n      });\n    }\n  };\n};\nexport const updateUserProfile = updatedUser => {\n  return async dispatch => {\n    try {\n      dispatch({\n        type: userActions.USER_PROFILE_UPDATE_LOADING\n      });\n      const baseRequest = new BaseRequest();\n      const ethAddress = await getCurrentAccount();\n\n      if (ethAddress) {\n        const windowObj = window;\n        const {\n          ethereum\n        } = windowObj;\n        const {\n          avatar\n        } = updatedUser;\n        await ethereum.sendAsync({\n          method: 'eth_signTypedData',\n          params: [getMessageParams(), ethAddress],\n          from: ethAddress\n        }, async function (err, result) {\n          if (err || result.error) {\n            const errMsg = err.message || result.error.message;\n            dispatchErrorWithMsg(dispatch, userActions.USER_PROFILE_UPDATE_FAILURE, errMsg);\n          } else {\n            const response = await baseRequest.post(`/user/update-profile`, {\n              avatar,\n              signature: result.result\n            });\n            const resObj = await response.json();\n\n            if (resObj.status && resObj.status === 200 && resObj.data) {\n              const {\n                user\n              } = resObj.data;\n              dispatch(alertSuccess('Update profile successful!'));\n              dispatch({\n                type: userActions.USER_LOGIN_SUCCESS,\n                payload: user\n              });\n              dispatch({\n                type: userActions.USER_PROFILE_UPDATE_SUCCESS,\n                payload: user\n              });\n            }\n\n            if (resObj.status && resObj.status !== 200) {\n              dispatchErrorWithMsg(dispatch, userActions.USER_PROFILE_UPDATE_FAILURE, resObj.message);\n            }\n          }\n        });\n      }\n    } catch (error) {\n      dispatchErrorWithMsg(dispatch, userActions.USER_PROFILE_UPDATE_FAILURE, error.message);\n    }\n  };\n};\nexport const joinPool = (connectedAccount, library, poolId) => {\n  return async (dispatch, getState) => {\n    try {\n      const baseRequest = new BaseRequest();\n      const connector = getState().connector.data;\n      const paramsWithConnector = getParamsWithConnector(connectedAccount)[connector];\n\n      if (connectedAccount && library && paramsWithConnector) {\n        const provider = library.provider;\n\n        if (connector !== ConnectorNames.WalletConnect) {\n          const res = await provider.sendAsync({\n            method: paramsWithConnector.method,\n            params: paramsWithConnector.params\n          }, async function (err, result) {\n            if (err || result.error) {\n              const errMsg = err.message || err.error || result.error.message;\n              console.log('Error when signing message: ', errMsg);\n              dispatchErrorWithMsg(dispatch, userActions.INVESTOR_LOGIN_FAILURE, errMsg);\n            } else {\n              console.log(result.result);\n              const response = await baseRequest.post(`/user/login`, {\n                signature: result.result,\n                wallet_address: connectedAccount\n              });\n              const resObj = await response.json();\n\n              if (resObj.status && resObj.status === 200 && resObj.data) {\n                const {\n                  token,\n                  user\n                } = resObj.data;\n                localStorage.setItem('investor_access_token', token.token);\n                dispatch({\n                  type: walletActions.WALLET_CONNECT_LAYER2_SUCCESS\n                });\n                dispatch({\n                  type: userActions.INVESTOR_LOGIN_SUCCESS,\n                  payload: user\n                });\n              }\n\n              if (resObj.status && resObj.status !== 200) {\n                if (resObj.status == 404) {\n                  // redirect to register page\n                  dispatch(alertFailure(resObj.message));\n                  dispatchErrorWithMsg(dispatch, userActions.INVESTOR_LOGIN_FAILURE, '');\n                } else {\n                  // show error\n                  console.log('RESPONSE Login: ', resObj);\n                  dispatch(alertFailure(resObj.message));\n                  dispatchErrorWithMsg(dispatch, userActions.INVESTOR_LOGIN_FAILURE, '');\n                }\n              }\n            }\n          });\n        } else {\n          var rawMessage = MESSAGE_INVESTOR_SIGNATURE;\n          var rawMessageLength = new Blob([rawMessage]).size;\n          var message = ethers.utils.toUtf8Bytes(\"\\x19Ethereum Signed Message:\\n\" + rawMessageLength + rawMessage);\n          var messageHash = ethers.utils.keccak256(message);\n          var params = [connectedAccount, messageHash];\n          await library.provider.enable();\n          var signature = await library.provider.wc.signMessage(params);\n          console.log(signature);\n        }\n      }\n    } catch (error) {\n      console.log('ERROR Login: ', error);\n      dispatch(alertFailure(error.message));\n      dispatchErrorWithMsg(dispatch, userActions.INVESTOR_LOGIN_FAILURE, '');\n    }\n  };\n};","map":{"version":3,"sources":["/Users/lehoa/icetea/work/redkite/frontend-user/src/store/actions/user.ts"],"names":["alertFailure","alertSuccess","ConnectorNames","userActions","walletActions","alertActions","BaseRequest","getWeb3Instance","ethers","MESSAGE_INVESTOR_SIGNATURE","process","env","REACT_APP_MESSAGE_INVESTOR_SIGNATURE","getMessageParams","msgSignature","type","name","value","getParamsWithConnector","connectedAccount","BSC","method","params","WalletConnect","WalletLinkConnect","Fortmatic","MetaMask","dispatchErrorWithMsg","dispatch","action","msg","payload","getCurrentAccount","web3Instance","accounts","eth","getAccounts","length","undefined","logout","isInvestor","localStorage","removeItem","USER_LOGOUT","INVESTOR_LOGOUT","resetUserState","USER_PURGE","INVESTOR_PURGE","clearUserProfileUpdate","USER_PROFILE_UPDATE_CLEAR_ERROR","login","library","getState","INVESTOR_LOGIN_LOADING","baseRequest","connector","data","paramsWithConnector","provider","res","sendAsync","err","result","error","errMsg","message","console","log","INVESTOR_LOGIN_FAILURE","response","post","signature","wallet_address","resObj","json","status","token","user","setItem","WALLET_CONNECT_LAYER2_SUCCESS","INVESTOR_LOGIN_SUCCESS","rawMessage","rawMessageLength","Blob","size","utils","toUtf8Bytes","messageHash","keccak256","enable","wc","signMessage","register","email","address","INVESTOR_REGISTER_LOADING","INVESTOR_REGISTER_FAILURE","SUCCESS_MESSAGE","INVESTOR_REGISTER_SUCCESS","connectWallet","USER_CONNECT_WALLET_LOADING","windowObj","window","ethereum","request","loginUser","USER_CONNECT_WALLET_SUCCESS","USER_CONNECT_WALLET_FAILURE","getUserDetail","USER_PROFILE_LOADING","get","USER_PROFILE_SUCCESS","USER_PROFILE_FAILURE","updateUserProfile","updatedUser","USER_PROFILE_UPDATE_LOADING","ethAddress","avatar","from","USER_PROFILE_UPDATE_FAILURE","USER_LOGIN_SUCCESS","USER_PROFILE_UPDATE_SUCCESS","joinPool","poolId"],"mappings":"AAAA,SAAQA,YAAR,EAAsBC,YAAtB,QAAyC,2BAAzC;AACA,SAASC,cAAT,QAA+C,4BAA/C;AACA,SAASC,WAAT,QAA4B,mBAA5B;AACA,SAASC,aAAT,QAA8B,qBAA9B;AACA,SAASC,YAAT,QAA6B,oBAA7B;AACA,SAASC,WAAT,QAA4B,uBAA5B;AACA,SAASC,eAAT,QAAgC,qBAAhC;AAIA,SAASC,MAAT,QAAuB,QAAvB;AAgBA,MAAMC,0BAA0B,GAAGC,OAAO,CAACC,GAAR,CAAYC,oCAAZ,IAAoD,EAAvF;;AAEA,MAAMC,gBAAgB,GAAG,MAAM;AAC7B,QAAMC,YAAY,GAAGL,0BAArB;AAEA,SAAO,CAAC;AACNM,IAAAA,IAAI,EAAE,QADA;AACe;AACrBC,IAAAA,IAAI,EAAE,SAFA;AAEe;AACrBC,IAAAA,KAAK,EAAEH,YAHD,CAGc;;AAHd,GAAD,CAAP;AAKD,CARD;;AAUA,OAAO,MAAMI,sBAAsB,GAAIC,gBAAD,KAA+B;AACnE,GAACjB,cAAc,CAACkB,GAAhB,GAAsB;AACpBC,IAAAA,MAAM,EAAE,UADY;AAEpBC,IAAAA,MAAM,EAAE,CAACH,gBAAD,EAAmBV,0BAAnB;AAFY,GAD6C;AAKnE,GAACP,cAAc,CAACqB,aAAhB,GAAgC;AAC9BF,IAAAA,MAAM,EAAE,UADsB;AAE9BC,IAAAA,MAAM,EAAE,CAACH,gBAAD,EAAmBV,0BAAnB;AAFsB,GALmC;AASnE,GAACP,cAAc,CAACsB,iBAAhB,GAAoC;AAClCH,IAAAA,MAAM,EAAE,UAD0B;AAElCC,IAAAA,MAAM,EAAE,CAACH,gBAAD,EAAmBV,0BAAnB;AAF0B,GAT+B;AAanE,GAACP,cAAc,CAACuB,SAAhB,GAA4B;AAC1BJ,IAAAA,MAAM,EAAE,mBADkB;AAE1BC,IAAAA,MAAM,EAAE,CAACT,gBAAgB,EAAjB,EAAqBM,gBAArB;AAFkB,GAbuC;AAiBnE,GAACjB,cAAc,CAACwB,QAAhB,GAA2B;AACzBL,IAAAA,MAAM,EAAE,mBADiB;AAEzBC,IAAAA,MAAM,EAAE,CAACT,gBAAgB,EAAjB,EAAqBM,gBAArB;AAFiB;AAjBwC,CAA/B,CAA/B;;AAuBP,MAAMQ,oBAAoB,GAAG,CAACC,QAAD,EAAqBC,MAArB,EAAqCC,GAArC,KAAqD;AAChFF,EAAAA,QAAQ,CAAC;AACPb,IAAAA,IAAI,EAAEc,MADC;AAEPE,IAAAA,OAAO,EAAED;AAFF,GAAD,CAAR;AAID,CALD;;AAOA,MAAME,iBAAiB,GAAG,YAAY;AACpC,QAAMC,YAAY,GAAG1B,eAAe,EAApC;AACA,QAAM2B,QAAQ,GAAG,OAAMD,YAAN,aAAMA,YAAN,uBAAMA,YAAY,CAAEE,GAAd,CAAkBC,WAAlB,EAAN,CAAjB;;AAEA,MAAIF,QAAQ,IAAIA,QAAQ,CAACG,MAAT,KAAoB,CAApC,EAAuC;AACrC,WAAOH,QAAQ,CAAC,CAAD,CAAf;AACD;;AAED,SAAOI,SAAP;AACD,CATD;;AAWA,OAAO,MAAMC,MAAM,GAAG,CAACC,UAAmB,GAAG,KAAvB,KAAiC;AACrDA,EAAAA,UAAU,GAAGC,YAAY,CAACC,UAAb,CAAwB,uBAAxB,CAAH,GAAqDD,YAAY,CAACC,UAAb,CAAwB,cAAxB,CAA/D;AAEA,SAAO;AACL3B,IAAAA,IAAI,EAAE,CAACyB,UAAD,GAAcrC,WAAW,CAACwC,WAA1B,GAAuCxC,WAAW,CAACyC;AADpD,GAAP;AAGD,CANM;AAQP,OAAO,MAAMC,cAAc,GAAG,CAACL,UAAmB,GAAG,KAAvB,KAAiC;AAC7D,SAAO;AACLzB,IAAAA,IAAI,EAAE,CAACyB,UAAD,GAAcrC,WAAW,CAAC2C,UAA1B,GAAsC3C,WAAW,CAAC4C;AADnD,GAAP;AAGD,CAJM;AAMP,OAAO,MAAMC,sBAAsB,GAAG,MAAM;AAC1C,SAAO;AACLjC,IAAAA,IAAI,EAAEZ,WAAW,CAAC8C;AADb,GAAP;AAGD,CAJM;AAMP,OAAO,MAAMC,KAAK,GAAG,CAAC/B,gBAAD,EAA2BgC,OAA3B,KAAqD;AACxE,SAAO,OAAOvB,QAAP,EAAmDwB,QAAnD,KAA2E;AAChF,QAAI;AACFxB,MAAAA,QAAQ,CAAC;AACPb,QAAAA,IAAI,EAAEZ,WAAW,CAACkD;AADX,OAAD,CAAR;AAIA,YAAMC,WAAW,GAAG,IAAIhD,WAAJ,EAApB;AACA,YAAMiD,SAAS,GAAGH,QAAQ,GAAGG,SAAX,CAAqBC,IAAvC;AACA,YAAMC,mBAAmB,GAAGvC,sBAAsB,CAACC,gBAAD,CAAtB,CAAyCoC,SAAzC,CAA5B;;AAEA,UAAIpC,gBAAgB,IAAIgC,OAApB,IAA+BM,mBAAnC,EAAwD;AACtD,cAAMC,QAAQ,GAAGP,OAAO,CAACO,QAAzB;;AACA,YAAIH,SAAS,KAAKrD,cAAc,CAACqB,aAAjC,EAAgD;AAC9C,gBAAMoC,GAAG,GAAG,MAAOD,QAAD,CAAkBE,SAAlB,CAA4B;AAC1CvC,YAAAA,MAAM,EAAEoC,mBAAmB,CAACpC,MADc;AAE1CC,YAAAA,MAAM,EAAEmC,mBAAmB,CAACnC;AAFc,WAA5B,EAGf,gBAAeuC,GAAf,EAA2BC,MAA3B,EAAwC;AACzC,gBAAID,GAAG,IAAIC,MAAM,CAACC,KAAlB,EAAyB;AACtB,oBAAMC,MAAM,GAAIH,GAAG,CAACI,OAAJ,IAAgBJ,GAAD,CAAaE,KAA7B,IAAuCD,MAAM,CAACC,KAAP,CAAaE,OAAnE;AACAC,cAAAA,OAAO,CAACC,GAAR,CAAY,8BAAZ,EAA4CH,MAA5C;AACCrC,cAAAA,oBAAoB,CAACC,QAAD,EAAWzB,WAAW,CAACiE,sBAAvB,EAA+CJ,MAA/C,CAApB;AACH,aAJD,MAIO;AACLE,cAAAA,OAAO,CAACC,GAAR,CAAYL,MAAM,CAACA,MAAnB;AACA,oBAAMO,QAAQ,GAAG,MAAMf,WAAW,CAACgB,IAAZ,CAAkB,aAAlB,EAAgC;AACrDC,gBAAAA,SAAS,EAAET,MAAM,CAACA,MADmC;AAErDU,gBAAAA,cAAc,EAAErD;AAFqC,eAAhC,CAAvB;AAKA,oBAAMsD,MAAM,GAAG,MAAMJ,QAAQ,CAACK,IAAT,EAArB;;AAEA,kBAAID,MAAM,CAACE,MAAP,IAAiBF,MAAM,CAACE,MAAP,KAAkB,GAAnC,IAA0CF,MAAM,CAACjB,IAArD,EAA2D;AACzD,sBAAM;AAAEoB,kBAAAA,KAAF;AAASC,kBAAAA;AAAT,oBAAkBJ,MAAM,CAACjB,IAA/B;AAEAf,gBAAAA,YAAY,CAACqC,OAAb,CAAqB,uBAArB,EAA8CF,KAAK,CAACA,KAApD;AAEAhD,gBAAAA,QAAQ,CAAC;AAAEb,kBAAAA,IAAI,EAAEX,aAAa,CAAC2E;AAAtB,iBAAD,CAAR;AAEAnD,gBAAAA,QAAQ,CAAC;AACPb,kBAAAA,IAAI,EAAEZ,WAAW,CAAC6E,sBADX;AAEPjD,kBAAAA,OAAO,EAAE8C;AAFF,iBAAD,CAAR;AAKD;;AAED,kBAAIJ,MAAM,CAACE,MAAP,IAAiBF,MAAM,CAACE,MAAP,KAAkB,GAAvC,EAA4C;AAC1C,oBAAIF,MAAM,CAACE,MAAP,IAAiB,GAArB,EAA0B;AACxB;AACA/C,kBAAAA,QAAQ,CAAC5B,YAAY,CAACyE,MAAM,CAACR,OAAR,CAAb,CAAR;AACAtC,kBAAAA,oBAAoB,CAACC,QAAD,EAAWzB,WAAW,CAACiE,sBAAvB,EAA+C,EAA/C,CAApB;AACD,iBAJD,MAIO;AACL;AACAF,kBAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ,EAAgCM,MAAhC;AACA7C,kBAAAA,QAAQ,CAAC5B,YAAY,CAACyE,MAAM,CAACR,OAAR,CAAb,CAAR;AACAtC,kBAAAA,oBAAoB,CAACC,QAAD,EAAWzB,WAAW,CAACiE,sBAAvB,EAA+C,EAA/C,CAApB;AACD;AACF;AACF;AACF,WA5CiB,CAAlB;AA6CD,SA9CD,MA8CO;AACL,cAAIa,UAAU,GAAGxE,0BAAjB;AACA,cAAIyE,gBAAgB,GAAG,IAAIC,IAAJ,CAAS,CAACF,UAAD,CAAT,EAAuBG,IAA9C;AACA,cAAInB,OAAO,GAAGzD,MAAM,CAAC6E,KAAP,CAAaC,WAAb,CAAyB,mCAAmCJ,gBAAnC,GAAsDD,UAA/E,CAAd;AACA,cAAIM,WAAW,GAAG/E,MAAM,CAAC6E,KAAP,CAAaG,SAAb,CAAuBvB,OAAvB,CAAlB;AACA,cAAI3C,MAAM,GAAG,CACXH,gBADW,EAEXoE,WAFW,CAAb;AAIA,gBAAOpC,OAAD,CAAiBO,QAAjB,CAA0B+B,MAA1B,EAAN;AAEA,cAAIlB,SAAS,GAAG,MAAOpB,OAAD,CAAiBO,QAAjB,CAA0BgC,EAA1B,CAA6BC,WAA7B,CAAyCrE,MAAzC,CAAtB;AACA4C,UAAAA,OAAO,CAACC,GAAR,CAAYI,SAAZ;AACD;AACF;AACF,KAxED,CAwEE,OAAOR,KAAP,EAAc;AACdG,MAAAA,OAAO,CAACC,GAAR,CAAY,eAAZ,EAA6BJ,KAA7B;AACAnC,MAAAA,QAAQ,CAAC5B,YAAY,CAAC+D,KAAK,CAACE,OAAP,CAAb,CAAR;AACAtC,MAAAA,oBAAoB,CAACC,QAAD,EAAWzB,WAAW,CAACiE,sBAAvB,EAA+C,EAA/C,CAApB;AACD;AACF,GA9ED;AA+ED,CAhFM;AAkFP,OAAO,MAAMwB,QAAQ,GAAG,CAAC;AAAEC,EAAAA,KAAF;AAASC,EAAAA,OAAO,EAAE3E,gBAAlB;AAAoCgC,EAAAA;AAApC,CAAD,KAAsE;AAC5F,SAAO,OAAOvB,QAAP,EAAmDwB,QAAnD,KAA2E;AAChFxB,IAAAA,QAAQ,CAAC;AACPb,MAAAA,IAAI,EAAEZ,WAAW,CAAC4F;AADX,KAAD,CAAR;;AAGA,QAAI;AACF,YAAMzC,WAAW,GAAG,IAAIhD,WAAJ,EAApB;AAEA,YAAMiD,SAAS,GAAGH,QAAQ,GAAGG,SAAX,CAAqBC,IAAvC;AACA,YAAMC,mBAAmB,GAAGvC,sBAAsB,CAACC,gBAAD,CAAtB,CAAyCoC,SAAzC,CAA5B;;AAEA,UAAIpC,gBAAgB,IAAIgC,OAApB,IAA+BM,mBAAnC,EAAwD;AACtD,cAAMC,QAAQ,GAAGP,OAAO,CAACO,QAAzB;AACAA,QAAAA,QAAQ,KAAI,MAAOA,QAAD,CAAkBE,SAAlB,CAA4B;AAC1CvC,UAAAA,MAAM,EAAEoC,mBAAmB,CAACpC,MADc;AAE1CC,UAAAA,MAAM,EAAEmC,mBAAmB,CAACnC;AAFc,SAA5B,EAGf,gBAAeuC,GAAf,EAA2BC,MAA3B,EAAwC;AACzC,cAAID,GAAG,IAAIC,MAAM,CAACC,KAAlB,EAAyB;AACtB,kBAAMC,MAAM,GAAIH,GAAG,CAACI,OAAJ,IAAgBJ,GAAD,CAAaE,KAA7B,IAAuCD,MAAM,CAACC,KAAP,CAAaE,OAAnE;AACCtC,YAAAA,oBAAoB,CAACC,QAAD,EAAWzB,WAAW,CAAC6F,yBAAvB,EAAkDhC,MAAlD,CAApB;AACA;AACH;;AAED,gBAAMK,QAAQ,GAAG,MAAMf,WAAW,CAACgB,IAAZ,CAAkB,iBAAlB,EAAoC;AACzDuB,YAAAA,KADyD;AAEzDrB,YAAAA,cAAc,EAAErD,gBAFyC;AAGzDoD,YAAAA,SAAS,EAAET,MAAM,CAACA;AAHuC,WAApC,CAAvB;AAMA,gBAAMW,MAAM,GAAG,MAAMJ,QAAQ,CAACK,IAAT,EAArB;;AAEA,cAAID,MAAM,CAACE,MAAP,IAAiBF,MAAM,CAACE,MAAP,KAAkB,GAAvC,EAA4C;AAE1C,gBAAIF,MAAM,CAACjB,IAAX,EAAiB;AACf,oBAAM;AAAEoB,gBAAAA,KAAF;AAASC,gBAAAA;AAAT,kBAAkBJ,MAAM,CAACjB,IAA/B;AAEAf,cAAAA,YAAY,CAACqC,OAAb,CAAqB,uBAArB,EAA8CF,KAAK,CAACA,KAApD;AAEAhD,cAAAA,QAAQ,CAAC;AAAEb,gBAAAA,IAAI,EAAEX,aAAa,CAAC2E;AAAtB,eAAD,CAAR;AAEAnD,cAAAA,QAAQ,CAAC;AACPb,gBAAAA,IAAI,EAAEV,YAAY,CAAC4F,eADZ;AAEPlE,gBAAAA,OAAO,EAAE;AAFF,eAAD,CAAR;AAKAH,cAAAA,QAAQ,CAAC;AACPb,gBAAAA,IAAI,EAAEZ,WAAW,CAAC+F,yBADX;AAEPnE,gBAAAA,OAAO,EAAE8C;AAFF,eAAD,CAAR;AAKAjD,cAAAA,QAAQ,CAAC;AACPb,gBAAAA,IAAI,EAAEZ,WAAW,CAAC6E,sBADX;AAEPjD,gBAAAA,OAAO,EAAE8C;AAFF,eAAD,CAAR;AAKD,aAtBD,MAsBO;AACLjD,cAAAA,QAAQ,CAAC;AACPb,gBAAAA,IAAI,EAAEV,YAAY,CAAC4F,eADZ;AAEPlE,gBAAAA,OAAO,EAAE0C,MAAM,CAACR;AAFT,eAAD,CAAR;AAKArC,cAAAA,QAAQ,CAAC;AACPb,gBAAAA,IAAI,EAAEZ,WAAW,CAAC+F,yBADX;AAEPnE,gBAAAA,OAAO,EAAE0C,MAAM,CAACR;AAFT,eAAD,CAAR;AAID;AAEF;;AAED,cAAIQ,MAAM,CAACE,MAAP,IAAiBF,MAAM,CAACE,MAAP,KAAkB,GAAvC,EAA4C;AAC1CT,YAAAA,OAAO,CAACC,GAAR,CAAY,qBAAZ,EAAmCM,MAAnC;AACA7C,YAAAA,QAAQ,CAAC5B,YAAY,CAACyE,MAAM,CAACR,OAAR,CAAb,CAAR;AACAtC,YAAAA,oBAAoB,CAACC,QAAD,EAAWzB,WAAW,CAAC6F,yBAAvB,EAAkD,EAAlD,CAApB;AACD;AACF,SA7DiB,CAAV,CAAR;AA8DD;AACF,KAvED,CAuEE,OAAOjC,KAAP,EAAc;AACdG,MAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ,EAAgCJ,KAAhC;AACAnC,MAAAA,QAAQ,CAAC5B,YAAY,CAAC+D,KAAK,CAACE,OAAP,CAAb,CAAR;AACAtC,MAAAA,oBAAoB,CAACC,QAAD,EAAWzB,WAAW,CAAC6F,yBAAvB,EAAkD,EAAlD,CAApB;AACD;AACF,GAhFD;AAiFD,CAlFM;AAoFP,OAAO,MAAMG,aAAa,GAAG,MAAM;AACjC,SAAO,MAAOvE,QAAP,IAAsD;AAC3DA,IAAAA,QAAQ,CAAC;AAAEb,MAAAA,IAAI,EAAEZ,WAAW,CAACiG;AAApB,KAAD,CAAR;;AACA,QAAI;AACF,YAAMC,SAAS,GAAGC,MAAlB;AACA,YAAM;AAAEC,QAAAA;AAAF,UAAeF,SAArB;AACA,YAAMnE,QAAQ,GAAG,MAAMqE,QAAQ,CAACC,OAAT,CAAiB;AAAEnF,QAAAA,MAAM,EAAE;AAAV,OAAjB,CAAvB;AACA,YAAMoF,SAAS,GAAGvE,QAAQ,CAACG,MAAT,GAAkBH,QAAQ,CAAC,CAAD,CAA1B,GAAgC,EAAlD;;AAEA,UAAIuE,SAAJ,EAAe;AACb7E,QAAAA,QAAQ,CAAC;AACPb,UAAAA,IAAI,EAAEZ,WAAW,CAACuG,2BADX;AAEP3E,UAAAA,OAAO,EAAE0E;AAFF,SAAD,CAAR;AAID,OALD,MAKO;AACL7E,QAAAA,QAAQ,CAACW,MAAM,EAAP,CAAR;AACD;AACF,KAdD,CAcE,OAAOwB,KAAP,EAAc;AACdnC,MAAAA,QAAQ,CAAC;AACPb,QAAAA,IAAI,EAAEZ,WAAW,CAACwG,2BADX;AAEP5E,QAAAA,OAAO,EAAEgC;AAFF,OAAD,CAAR;AAID;AACF,GAtBD;AAuBD,CAxBM;AA0BP,OAAO,MAAM6C,aAAa,GAAG,MAAM;AACjC,SAAO,MAAOhF,QAAP,IAAsD;AAC3DA,IAAAA,QAAQ,CAAC;AAAEb,MAAAA,IAAI,EAAEZ,WAAW,CAAC0G;AAApB,KAAD,CAAR;;AACA,QAAI;AACF,YAAMvD,WAAW,GAAG,IAAIhD,WAAJ,EAApB;AAEA,YAAM+D,QAAQ,GAAG,MAAMf,WAAW,CAACwD,GAAZ,CAAgB,eAAhB,CAAvB;AACA,YAAMrC,MAAM,GAAG,MAAMJ,QAAQ,CAACK,IAAT,EAArB;;AAEA,UAAID,MAAM,CAACE,MAAP,IAAiBF,MAAM,CAACE,MAAP,KAAkB,GAAvC,EAA4C;AAC1C/C,QAAAA,QAAQ,CAAC;AACPb,UAAAA,IAAI,EAAEZ,WAAW,CAAC4G,oBADX;AAEPhF,UAAAA,OAAO,EAAE0C,MAAM,CAACjB,IAAP,CAAYqB;AAFd,SAAD,CAAR;AAID,OALD,MAKO;AACLjD,QAAAA,QAAQ,CAAC;AACPb,UAAAA,IAAI,EAAEZ,WAAW,CAAC6G,oBADX;AAEPjF,UAAAA,OAAO,EAAE0C,MAAM,CAACR;AAFT,SAAD,CAAR;AAID;AACF,KAjBD,CAiBE,OAAOF,KAAP,EAAc;AACdnC,MAAAA,QAAQ,CAAC;AACPb,QAAAA,IAAI,EAAEZ,WAAW,CAAC6G,oBADX;AAEPjF,QAAAA,OAAO,EAAEgC;AAFF,OAAD,CAAR;AAID;AACF,GAzBD;AA0BD,CA3BM;AA6BP,OAAO,MAAMkD,iBAAiB,GAAIC,WAAD,IAAmC;AAClE,SAAO,MAAOtF,QAAP,IAAsD;AAC3D,QAAI;AACFA,MAAAA,QAAQ,CAAC;AACPb,QAAAA,IAAI,EAAEZ,WAAW,CAACgH;AADX,OAAD,CAAR;AAIA,YAAM7D,WAAW,GAAG,IAAIhD,WAAJ,EAApB;AACA,YAAM8G,UAAU,GAAG,MAAMpF,iBAAiB,EAA1C;;AAEA,UAAIoF,UAAJ,EAAgB;AACd,cAAMf,SAAS,GAAGC,MAAlB;AACA,cAAM;AAAEC,UAAAA;AAAF,YAAeF,SAArB;AACA,cAAM;AAAEgB,UAAAA;AAAF,YAAaH,WAAnB;AACD,cAAMX,QAAQ,CAAC3C,SAAT,CAAmB;AACpBvC,UAAAA,MAAM,EAAE,mBADY;AAEpBC,UAAAA,MAAM,EAAE,CAACT,gBAAgB,EAAjB,EAAqBuG,UAArB,CAFY;AAGpBE,UAAAA,IAAI,EAAEF;AAHc,SAAnB,EAIF,gBAAevD,GAAf,EAA2BC,MAA3B,EAAwC;AACzC,cAAID,GAAG,IAAIC,MAAM,CAACC,KAAlB,EAAyB;AACtB,kBAAMC,MAAM,GAAGH,GAAG,CAACI,OAAJ,IAAeH,MAAM,CAACC,KAAP,CAAaE,OAA3C;AACCtC,YAAAA,oBAAoB,CAACC,QAAD,EAAWzB,WAAW,CAACoH,2BAAvB,EAAoDvD,MAApD,CAApB;AACH,WAHD,MAGO;AACL,kBAAMK,QAAQ,GAAG,MAAMf,WAAW,CAACgB,IAAZ,CAAkB,sBAAlB,EAAyC;AAC9D+C,cAAAA,MAD8D;AAE9D9C,cAAAA,SAAS,EAAET,MAAM,CAACA;AAF4C,aAAzC,CAAvB;AAKA,kBAAMW,MAAM,GAAG,MAAMJ,QAAQ,CAACK,IAAT,EAArB;;AAEA,gBAAID,MAAM,CAACE,MAAP,IAAiBF,MAAM,CAACE,MAAP,KAAkB,GAAnC,IAA0CF,MAAM,CAACjB,IAArD,EAA2D;AACzD,oBAAM;AAAEqB,gBAAAA;AAAF,kBAAWJ,MAAM,CAACjB,IAAxB;AAEA5B,cAAAA,QAAQ,CAAC3B,YAAY,CAAC,4BAAD,CAAb,CAAR;AAEA2B,cAAAA,QAAQ,CAAC;AACPb,gBAAAA,IAAI,EAAEZ,WAAW,CAACqH,kBADX;AAEPzF,gBAAAA,OAAO,EAAE8C;AAFF,eAAD,CAAR;AAKAjD,cAAAA,QAAQ,CAAC;AACPb,gBAAAA,IAAI,EAAEZ,WAAW,CAACsH,2BADX;AAEP1F,gBAAAA,OAAO,EAAE8C;AAFF,eAAD,CAAR;AAID;;AAED,gBAAIJ,MAAM,CAACE,MAAP,IAAiBF,MAAM,CAACE,MAAP,KAAkB,GAAvC,EAA4C;AAC1ChD,cAAAA,oBAAoB,CAACC,QAAD,EAAWzB,WAAW,CAACoH,2BAAvB,EAAoD9C,MAAM,CAACR,OAA3D,CAApB;AACD;AACF;AACF,SApCI,CAAN;AAqCA;AACF,KAlDD,CAkDE,OAAOF,KAAP,EAAc;AACdpC,MAAAA,oBAAoB,CAACC,QAAD,EAAWzB,WAAW,CAACoH,2BAAvB,EAAoDxD,KAAK,CAACE,OAA1D,CAApB;AACD;AACF,GAtDD;AAuDD,CAxDM;AA0DP,OAAO,MAAMyD,QAAQ,GAAG,CAACvG,gBAAD,EAA2BgC,OAA3B,EAAkDwE,MAAlD,KAAsE;AAC5F,SAAO,OAAO/F,QAAP,EAAmDwB,QAAnD,KAA2E;AAChF,QAAI;AACF,YAAME,WAAW,GAAG,IAAIhD,WAAJ,EAApB;AACA,YAAMiD,SAAS,GAAGH,QAAQ,GAAGG,SAAX,CAAqBC,IAAvC;AACA,YAAMC,mBAAmB,GAAGvC,sBAAsB,CAACC,gBAAD,CAAtB,CAAyCoC,SAAzC,CAA5B;;AAEA,UAAIpC,gBAAgB,IAAIgC,OAApB,IAA+BM,mBAAnC,EAAwD;AACtD,cAAMC,QAAQ,GAAGP,OAAO,CAACO,QAAzB;;AACA,YAAIH,SAAS,KAAKrD,cAAc,CAACqB,aAAjC,EAAgD;AAC9C,gBAAMoC,GAAG,GAAG,MAAOD,QAAD,CAAkBE,SAAlB,CAA4B;AAC1CvC,YAAAA,MAAM,EAAEoC,mBAAmB,CAACpC,MADc;AAE1CC,YAAAA,MAAM,EAAEmC,mBAAmB,CAACnC;AAFc,WAA5B,EAGf,gBAAeuC,GAAf,EAA2BC,MAA3B,EAAwC;AACzC,gBAAID,GAAG,IAAIC,MAAM,CAACC,KAAlB,EAAyB;AACtB,oBAAMC,MAAM,GAAIH,GAAG,CAACI,OAAJ,IAAgBJ,GAAD,CAAaE,KAA7B,IAAuCD,MAAM,CAACC,KAAP,CAAaE,OAAnE;AACAC,cAAAA,OAAO,CAACC,GAAR,CAAY,8BAAZ,EAA4CH,MAA5C;AACCrC,cAAAA,oBAAoB,CAACC,QAAD,EAAWzB,WAAW,CAACiE,sBAAvB,EAA+CJ,MAA/C,CAApB;AACH,aAJD,MAIO;AACLE,cAAAA,OAAO,CAACC,GAAR,CAAYL,MAAM,CAACA,MAAnB;AACA,oBAAMO,QAAQ,GAAG,MAAMf,WAAW,CAACgB,IAAZ,CAAkB,aAAlB,EAAgC;AACrDC,gBAAAA,SAAS,EAAET,MAAM,CAACA,MADmC;AAErDU,gBAAAA,cAAc,EAAErD;AAFqC,eAAhC,CAAvB;AAKA,oBAAMsD,MAAM,GAAG,MAAMJ,QAAQ,CAACK,IAAT,EAArB;;AAEA,kBAAID,MAAM,CAACE,MAAP,IAAiBF,MAAM,CAACE,MAAP,KAAkB,GAAnC,IAA0CF,MAAM,CAACjB,IAArD,EAA2D;AACzD,sBAAM;AAAEoB,kBAAAA,KAAF;AAASC,kBAAAA;AAAT,oBAAkBJ,MAAM,CAACjB,IAA/B;AAEAf,gBAAAA,YAAY,CAACqC,OAAb,CAAqB,uBAArB,EAA8CF,KAAK,CAACA,KAApD;AAEAhD,gBAAAA,QAAQ,CAAC;AAAEb,kBAAAA,IAAI,EAAEX,aAAa,CAAC2E;AAAtB,iBAAD,CAAR;AAEAnD,gBAAAA,QAAQ,CAAC;AACPb,kBAAAA,IAAI,EAAEZ,WAAW,CAAC6E,sBADX;AAEPjD,kBAAAA,OAAO,EAAE8C;AAFF,iBAAD,CAAR;AAKD;;AAED,kBAAIJ,MAAM,CAACE,MAAP,IAAiBF,MAAM,CAACE,MAAP,KAAkB,GAAvC,EAA4C;AAC1C,oBAAIF,MAAM,CAACE,MAAP,IAAiB,GAArB,EAA0B;AACxB;AACA/C,kBAAAA,QAAQ,CAAC5B,YAAY,CAACyE,MAAM,CAACR,OAAR,CAAb,CAAR;AACAtC,kBAAAA,oBAAoB,CAACC,QAAD,EAAWzB,WAAW,CAACiE,sBAAvB,EAA+C,EAA/C,CAApB;AACD,iBAJD,MAIO;AACL;AACAF,kBAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ,EAAgCM,MAAhC;AACA7C,kBAAAA,QAAQ,CAAC5B,YAAY,CAACyE,MAAM,CAACR,OAAR,CAAb,CAAR;AACAtC,kBAAAA,oBAAoB,CAACC,QAAD,EAAWzB,WAAW,CAACiE,sBAAvB,EAA+C,EAA/C,CAApB;AACD;AACF;AACF;AACF,WA5CiB,CAAlB;AA6CD,SA9CD,MA8CO;AACL,cAAIa,UAAU,GAAGxE,0BAAjB;AACA,cAAIyE,gBAAgB,GAAG,IAAIC,IAAJ,CAAS,CAACF,UAAD,CAAT,EAAuBG,IAA9C;AACA,cAAInB,OAAO,GAAGzD,MAAM,CAAC6E,KAAP,CAAaC,WAAb,CAAyB,mCAAmCJ,gBAAnC,GAAsDD,UAA/E,CAAd;AACA,cAAIM,WAAW,GAAG/E,MAAM,CAAC6E,KAAP,CAAaG,SAAb,CAAuBvB,OAAvB,CAAlB;AACA,cAAI3C,MAAM,GAAG,CACXH,gBADW,EAEXoE,WAFW,CAAb;AAIA,gBAAOpC,OAAD,CAAiBO,QAAjB,CAA0B+B,MAA1B,EAAN;AAEA,cAAIlB,SAAS,GAAG,MAAOpB,OAAD,CAAiBO,QAAjB,CAA0BgC,EAA1B,CAA6BC,WAA7B,CAAyCrE,MAAzC,CAAtB;AACA4C,UAAAA,OAAO,CAACC,GAAR,CAAYI,SAAZ;AACD;AACF;AACF,KApED,CAoEE,OAAOR,KAAP,EAAc;AACdG,MAAAA,OAAO,CAACC,GAAR,CAAY,eAAZ,EAA6BJ,KAA7B;AACAnC,MAAAA,QAAQ,CAAC5B,YAAY,CAAC+D,KAAK,CAACE,OAAP,CAAb,CAAR;AACAtC,MAAAA,oBAAoB,CAACC,QAAD,EAAWzB,WAAW,CAACiE,sBAAvB,EAA+C,EAA/C,CAApB;AACD;AACF,GA1ED;AA2ED,CA5EM","sourcesContent":["import {alertFailure, alertSuccess} from '../../store/actions/alert';\nimport { ConnectorNames, connectorNames } from '../../constants/connectors';\nimport { userActions } from '../constants/user';\nimport { walletActions } from '../constants/wallet';\nimport { alertActions } from '../constants/alert';\nimport { BaseRequest } from '../../request/Request';\nimport { getWeb3Instance } from '../../services/web3';\nimport { AnyAction, Dispatch } from 'redux';\nimport { ThunkDispatch } from 'redux-thunk';\nimport { Web3Provider } from '@ethersproject/providers'\nimport { ethers } from 'ethers';\n\ntype UserRegisterProps = {\n  email: string;\n  address: string;\n  library: Web3Provider;\n}\n\ntype UserProfileProps = {\n  firstName: string;\n  lastName: string;\n  email: string;\n  userName: string;\n  avatar: string;\n}\n\nconst MESSAGE_INVESTOR_SIGNATURE = process.env.REACT_APP_MESSAGE_INVESTOR_SIGNATURE || \"\";\n\nconst getMessageParams = () => {\n  const msgSignature = MESSAGE_INVESTOR_SIGNATURE;\n\n  return [{\n    type: 'string',      // Any valid solidity type\n    name: 'Message',     // Any string label you want\n    value: msgSignature // The value to sign\n  }]\n}\n\nexport const getParamsWithConnector = (connectedAccount: string) => ({\n  [ConnectorNames.BSC]: {\n    method: 'eth_sign',\n    params: [connectedAccount, MESSAGE_INVESTOR_SIGNATURE]\n  },\n  [ConnectorNames.WalletConnect]: {\n    method: 'eth_sign',\n    params: [connectedAccount, MESSAGE_INVESTOR_SIGNATURE]\n  },\n  [ConnectorNames.WalletLinkConnect]: {\n    method: 'eth_sign',\n    params: [connectedAccount, MESSAGE_INVESTOR_SIGNATURE]\n  },\n  [ConnectorNames.Fortmatic]: {\n    method: 'eth_signTypedData',\n    params: [getMessageParams(), connectedAccount]\n  },\n  [ConnectorNames.MetaMask]: {\n    method: 'eth_signTypedData',\n    params: [getMessageParams(), connectedAccount]\n  },\n})\n\nconst dispatchErrorWithMsg = (dispatch: Dispatch, action: string, msg: string) => {\n  dispatch({\n    type: action,\n    payload: msg\n  })\n}\n\nconst getCurrentAccount = async () => {\n  const web3Instance = getWeb3Instance();\n  const accounts = await web3Instance?.eth.getAccounts();\n\n  if (accounts && accounts.length !== 0) {\n    return accounts[0];\n  }\n\n  return undefined;\n}\n\nexport const logout = (isInvestor: boolean = false) => {\n  isInvestor ? localStorage.removeItem(\"investor_access_token\"): localStorage.removeItem(\"access_token\");\n\n  return {\n    type: !isInvestor ? userActions.USER_LOGOUT: userActions.INVESTOR_LOGOUT\n  }\n}\n\nexport const resetUserState = (isInvestor: boolean = false) => {\n  return {\n    type: !isInvestor ? userActions.USER_PURGE: userActions.INVESTOR_PURGE\n  }\n}\n\nexport const clearUserProfileUpdate = () => {\n  return {\n    type: userActions.USER_PROFILE_UPDATE_CLEAR_ERROR\n  }\n}\n\nexport const login = (connectedAccount: string, library: Web3Provider) => {\n  return async (dispatch: ThunkDispatch<{}, {}, AnyAction>, getState: () => any) => {\n    try {\n      dispatch({\n        type: userActions.INVESTOR_LOGIN_LOADING\n      });\n\n      const baseRequest = new BaseRequest();\n      const connector = getState().connector.data;\n      const paramsWithConnector = getParamsWithConnector(connectedAccount)[connector as connectorNames];\n\n      if (connectedAccount && library && paramsWithConnector) {\n        const provider = library.provider;\n        if (connector !== ConnectorNames.WalletConnect) {\n          const res = await (provider as any).sendAsync({\n              method: paramsWithConnector.method,\n              params: paramsWithConnector.params\n          }, async function(err: Error, result: any) {\n            if (err || result.error) {\n               const errMsg = (err.message || (err as any).error) || result.error.message\n               console.log('Error when signing message: ', errMsg);\n                dispatchErrorWithMsg(dispatch, userActions.INVESTOR_LOGIN_FAILURE, errMsg);\n            } else {\n              console.log(result.result);\n              const response = await baseRequest.post(`/user/login`, {\n                signature: result.result,\n                wallet_address: connectedAccount,\n              }) as any;\n\n              const resObj = await response.json();\n\n              if (resObj.status && resObj.status === 200 && resObj.data) {\n                const { token, user } = resObj.data;\n\n                localStorage.setItem('investor_access_token', token.token);\n\n                dispatch({ type: walletActions.WALLET_CONNECT_LAYER2_SUCCESS });\n\n                dispatch({\n                  type: userActions.INVESTOR_LOGIN_SUCCESS,\n                  payload: user\n                });\n\n              }\n\n              if (resObj.status && resObj.status !== 200) {\n                if (resObj.status == 404) {\n                  // redirect to register page\n                  dispatch(alertFailure(resObj.message));\n                  dispatchErrorWithMsg(dispatch, userActions.INVESTOR_LOGIN_FAILURE, '');\n                } else {\n                  // show error\n                  console.log('RESPONSE Login: ', resObj);\n                  dispatch(alertFailure(resObj.message));\n                  dispatchErrorWithMsg(dispatch, userActions.INVESTOR_LOGIN_FAILURE, '');\n                }\n              }\n            }\n          });\n        } else {\n          var rawMessage = MESSAGE_INVESTOR_SIGNATURE;\n          var rawMessageLength = new Blob([rawMessage]).size\n          var message = ethers.utils.toUtf8Bytes(\"\\x19Ethereum Signed Message:\\n\" + rawMessageLength + rawMessage)\n          var messageHash = ethers.utils.keccak256(message)\n          var params = [\n            connectedAccount,\n            messageHash\n          ]\n          await (library as any).provider.enable();\n\n          var signature = await (library as any).provider.wc.signMessage(params);\n          console.log(signature);\n        }\n      }\n    } catch (error) {\n      console.log('ERROR Login: ', error);\n      dispatch(alertFailure(error.message));\n      dispatchErrorWithMsg(dispatch, userActions.INVESTOR_LOGIN_FAILURE, '');\n    }\n  }\n}\n\nexport const register = ({ email, address: connectedAccount, library }: UserRegisterProps) => {\n  return async (dispatch: ThunkDispatch<{}, {}, AnyAction>, getState: () => any) => {\n    dispatch({\n      type: userActions.INVESTOR_REGISTER_LOADING\n    });\n    try {\n      const baseRequest = new BaseRequest();\n\n      const connector = getState().connector.data;\n      const paramsWithConnector = getParamsWithConnector(connectedAccount)[connector as connectorNames];\n\n      if (connectedAccount && library && paramsWithConnector) {\n        const provider = library.provider;\n        provider && await (provider as any).sendAsync({\n            method: paramsWithConnector.method,\n            params: paramsWithConnector.params\n        }, async function(err: Error, result: any) {\n          if (err || result.error) {\n             const errMsg = (err.message || (err as any).error) || result.error.message\n              dispatchErrorWithMsg(dispatch, userActions.INVESTOR_REGISTER_FAILURE, errMsg);\n              return;\n          }\n\n          const response = await baseRequest.post(`/user/register/`, {\n            email,\n            wallet_address: connectedAccount,\n            signature: result.result,\n          }) as any;\n\n          const resObj = await response.json();\n\n          if (resObj.status && resObj.status === 200) {\n\n            if (resObj.data) {\n              const { token, user } = resObj.data;\n\n              localStorage.setItem('investor_access_token', token.token);\n\n              dispatch({ type: walletActions.WALLET_CONNECT_LAYER2_SUCCESS });\n\n              dispatch({\n                type: alertActions.SUCCESS_MESSAGE,\n                payload: 'Register Account Successful'\n              });\n\n              dispatch({\n                type: userActions.INVESTOR_REGISTER_SUCCESS,\n                payload: user\n              });\n\n              dispatch({\n                type: userActions.INVESTOR_LOGIN_SUCCESS,\n                payload: user\n              });\n\n            } else {\n              dispatch({\n                type: alertActions.SUCCESS_MESSAGE,\n                payload: resObj.message\n              });\n\n              dispatch({\n                type: userActions.INVESTOR_REGISTER_SUCCESS,\n                payload: resObj.message\n              });\n            }\n\n          }\n\n          if (resObj.status && resObj.status !== 200) {\n            console.log('RESPONSE Register: ', resObj);\n            dispatch(alertFailure(resObj.message));\n            dispatchErrorWithMsg(dispatch, userActions.INVESTOR_REGISTER_FAILURE, '');\n          }\n        });\n      }\n    } catch (error) {\n      console.log('ERROR Register: ', error);\n      dispatch(alertFailure(error.message));\n      dispatchErrorWithMsg(dispatch, userActions.INVESTOR_REGISTER_FAILURE, '');\n    }\n  }\n};\n\nexport const connectWallet = () => {\n  return async (dispatch: ThunkDispatch<{}, {}, AnyAction>) => {\n    dispatch({ type: userActions.USER_CONNECT_WALLET_LOADING });\n    try {\n      const windowObj = window as any;\n      const { ethereum } = windowObj;\n      const accounts = await ethereum.request({ method: 'eth_requestAccounts' });\n      const loginUser = accounts.length ? accounts[0] : '';\n\n      if (loginUser) {\n        dispatch({\n          type: userActions.USER_CONNECT_WALLET_SUCCESS,\n          payload: loginUser\n        });\n      } else {\n        dispatch(logout());\n      }\n    } catch (error) {\n      dispatch({\n        type: userActions.USER_CONNECT_WALLET_FAILURE,\n        payload: error\n      });\n    }\n  }\n}\n\nexport const getUserDetail = () => {\n  return async (dispatch: ThunkDispatch<{}, {}, AnyAction>) => {\n    dispatch({ type: userActions.USER_PROFILE_LOADING });\n    try {\n      const baseRequest = new BaseRequest();\n\n      const response = await baseRequest.get('/user/profile') as any;\n      const resObj = await response.json();\n\n      if (resObj.status && resObj.status === 200) {\n        dispatch({\n          type: userActions.USER_PROFILE_SUCCESS,\n          payload: resObj.data.user\n        })\n      } else {\n        dispatch({\n          type: userActions.USER_PROFILE_FAILURE,\n          payload: resObj.message\n        })\n      }\n    } catch (error) {\n      dispatch({\n        type: userActions.USER_PROFILE_FAILURE,\n        payload: error\n      });\n    }\n  }\n}\n\nexport const updateUserProfile = (updatedUser: UserProfileProps) => {\n  return async (dispatch: ThunkDispatch<{}, {}, AnyAction>) => {\n    try {\n      dispatch({\n        type: userActions.USER_PROFILE_UPDATE_LOADING\n      });\n\n      const baseRequest = new BaseRequest();\n      const ethAddress = await getCurrentAccount();\n\n      if (ethAddress) {\n        const windowObj = window as any;\n        const { ethereum } = windowObj;\n        const { avatar } = updatedUser;\n       await ethereum.sendAsync({\n            method: 'eth_signTypedData',\n            params: [getMessageParams(), ethAddress],\n            from: ethAddress,\n        }, async function(err: Error, result: any) {\n          if (err || result.error) {\n             const errMsg = err.message || result.error.message\n              dispatchErrorWithMsg(dispatch, userActions.USER_PROFILE_UPDATE_FAILURE, errMsg);\n          } else {\n            const response = await baseRequest.post(`/user/update-profile`, {\n              avatar,\n              signature: result.result\n            }) as any;\n\n            const resObj = await response.json();\n\n            if (resObj.status && resObj.status === 200 && resObj.data) {\n              const { user } = resObj.data;\n\n              dispatch(alertSuccess('Update profile successful!'));\n\n              dispatch({\n                type: userActions.USER_LOGIN_SUCCESS,\n                payload: user\n              });\n\n              dispatch({\n                type: userActions.USER_PROFILE_UPDATE_SUCCESS,\n                payload: user\n              });\n            }\n\n            if (resObj.status && resObj.status !== 200) {\n              dispatchErrorWithMsg(dispatch, userActions.USER_PROFILE_UPDATE_FAILURE, resObj.message);\n            }\n          }\n        });\n      }\n    } catch (error) {\n      dispatchErrorWithMsg(dispatch, userActions.USER_PROFILE_UPDATE_FAILURE, error.message);\n    }\n  }\n}\n\nexport const joinPool = (connectedAccount: string, library: Web3Provider, poolId?: number) => {\n  return async (dispatch: ThunkDispatch<{}, {}, AnyAction>, getState: () => any) => {\n    try {\n      const baseRequest = new BaseRequest();\n      const connector = getState().connector.data;\n      const paramsWithConnector = getParamsWithConnector(connectedAccount)[connector as connectorNames];\n\n      if (connectedAccount && library && paramsWithConnector) {\n        const provider = library.provider;\n        if (connector !== ConnectorNames.WalletConnect) {\n          const res = await (provider as any).sendAsync({\n              method: paramsWithConnector.method,\n              params: paramsWithConnector.params\n          }, async function(err: Error, result: any) {\n            if (err || result.error) {\n               const errMsg = (err.message || (err as any).error) || result.error.message\n               console.log('Error when signing message: ', errMsg);\n                dispatchErrorWithMsg(dispatch, userActions.INVESTOR_LOGIN_FAILURE, errMsg);\n            } else {\n              console.log(result.result);\n              const response = await baseRequest.post(`/user/login`, {\n                signature: result.result,\n                wallet_address: connectedAccount,\n              }) as any;\n\n              const resObj = await response.json();\n\n              if (resObj.status && resObj.status === 200 && resObj.data) {\n                const { token, user } = resObj.data;\n\n                localStorage.setItem('investor_access_token', token.token);\n\n                dispatch({ type: walletActions.WALLET_CONNECT_LAYER2_SUCCESS });\n\n                dispatch({\n                  type: userActions.INVESTOR_LOGIN_SUCCESS,\n                  payload: user\n                });\n\n              }\n\n              if (resObj.status && resObj.status !== 200) {\n                if (resObj.status == 404) {\n                  // redirect to register page\n                  dispatch(alertFailure(resObj.message));\n                  dispatchErrorWithMsg(dispatch, userActions.INVESTOR_LOGIN_FAILURE, '');\n                } else {\n                  // show error\n                  console.log('RESPONSE Login: ', resObj);\n                  dispatch(alertFailure(resObj.message));\n                  dispatchErrorWithMsg(dispatch, userActions.INVESTOR_LOGIN_FAILURE, '');\n                }\n              }\n            }\n          });\n        } else {\n          var rawMessage = MESSAGE_INVESTOR_SIGNATURE;\n          var rawMessageLength = new Blob([rawMessage]).size\n          var message = ethers.utils.toUtf8Bytes(\"\\x19Ethereum Signed Message:\\n\" + rawMessageLength + rawMessage)\n          var messageHash = ethers.utils.keccak256(message)\n          var params = [\n            connectedAccount,\n            messageHash\n          ]\n          await (library as any).provider.enable();\n\n          var signature = await (library as any).provider.wc.signMessage(params);\n          console.log(signature);\n        }\n      }\n    } catch (error) {\n      console.log('ERROR Login: ', error);\n      dispatch(alertFailure(error.message));\n      dispatchErrorWithMsg(dispatch, userActions.INVESTOR_LOGIN_FAILURE, '');\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}