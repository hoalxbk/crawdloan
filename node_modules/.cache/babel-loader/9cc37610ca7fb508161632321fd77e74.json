{"ast":null,"code":"import Web3 from 'web3';\nimport { ConnectorNames, connectorsByName } from '../constants/connectors';\nimport { ETH_CHAIN_ID } from '../constants/network';\nimport { NETWORK_AVAILABLE } from \"../constants\";\n\nconst POOL_ABI = require('../abi/Pool.json');\n\nconst NETWORK_URL = process.env.REACT_APP_NETWORK_URL || \"\";\nconst BSC_NETWORK_URL = process.env.REACT_APP_BSC_RPC_URL || \"\";\nexport const MAX_INT = '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';\nexport let SmartContractMethod;\n\n(function (SmartContractMethod) {\n  SmartContractMethod[\"Write\"] = \"Write\";\n  SmartContractMethod[\"Read\"] = \"Read\";\n})(SmartContractMethod || (SmartContractMethod = {}));\n\nexport const getWeb3Instance = () => {\n  const windowObj = window;\n  const {\n    ethereum,\n    web3\n  } = windowObj;\n\n  if (ethereum && ethereum.isMetaMask) {\n    return new Web3(ethereum);\n  }\n\n  if (web3) {\n    return new Web3(web3.currentProvider);\n  }\n\n  return null;\n};\nexport const isMetaMaskInstalled = () => {\n  const windowObj = window;\n  const {\n    ethereum\n  } = windowObj;\n  return ethereum && ethereum.isMetaMask;\n};\nexport const getProviderByNetwork = (networkName, appChainID, typeMethod, forceUsingEther) => {\n  if (forceUsingEther) {\n    return new Web3.providers.HttpProvider(NETWORK_URL);\n  }\n\n  if (appChainID && typeMethod === SmartContractMethod.Read) {\n    return new Web3.providers.HttpProvider(appChainID === ETH_CHAIN_ID ? NETWORK_URL : BSC_NETWORK_URL);\n  }\n\n  const provider = connectorsByName[networkName];\n  return provider;\n};\nexport const getContractInstance = (ABIContract, contractAddress, networkName = ConnectorNames.MetaMask, appChainID = ETH_CHAIN_ID, typeMethod = SmartContractMethod.Read, forceUsingEther = false) => {\n  const provider = getProviderByNetwork(networkName, appChainID, typeMethod, forceUsingEther);\n\n  if (provider) {\n    const web3Instance = new Web3(provider);\n    return new web3Instance.eth.Contract(ABIContract, contractAddress);\n  }\n\n  return;\n};\nexport const getContractInstanceWeb3 = (isEth = true) => {\n  let provider = new Web3.providers.HttpProvider(NETWORK_URL);\n\n  if (!isEth) {\n    provider = new Web3.providers.HttpProvider(BSC_NETWORK_URL);\n  }\n\n  let web3Instance = new Web3(provider);\n  return web3Instance;\n};\nexport const getPoolContract = ({\n  networkAvailable,\n  poolHash\n}) => {\n  if (networkAvailable == NETWORK_AVAILABLE.BSC) {\n    const web3Instance = getContractInstanceWeb3(false);\n    return new web3Instance.eth.Contract(POOL_ABI, poolHash);\n  } else if (networkAvailable == NETWORK_AVAILABLE.ETH) {\n    const web3Instance = getContractInstanceWeb3(true);\n    return new web3Instance.eth.Contract(POOL_ABI, poolHash);\n  } else {\n    return null;\n  }\n};\nexport const getContractInstanceWithEthereum = (ABIContract, contractAddress) => {\n  const windowObj = window;\n  const {\n    ethereum\n  } = windowObj;\n\n  if (ethereum && ethereum.isMetaMask) {\n    const web3Instance = new Web3(ethereum);\n    return new web3Instance.eth.Contract(ABIContract, contractAddress);\n  } else if (windowObj.web3) {\n    const web3Instance = new Web3(windowObj.web3.currentProvider);\n    return new web3Instance.eth.Contract(ABIContract, contractAddress);\n  } else {\n    return null;\n  }\n};\nexport const getContractInstanceWithBSC = (ABIContract, contractAddress) => {\n  const windowObj = window;\n  const {\n    ethereum\n  } = windowObj;\n  const web3Instance = new Web3(ethereum);\n  return new web3Instance.eth.Contract(ABIContract, contractAddress);\n};\nexport const convertFromWei = (value, unit = 'ether') => {\n  return Web3.utils.fromWei(value);\n};\nexport const convertToWei = (value, unit = 'ether') => {\n  // const webInstance = getWeb3Instance();\n  // // @ts-ignore\n  // return webInstance.utils.toWei(value, unit);\n  return Web3.utils.toWei(value);\n};\nexport const isValidAddress = address => {\n  return Web3.utils.isAddress(address);\n};\nexport const getETHBalance = async loginUser => {\n  const web3 = getWeb3Instance();\n\n  if (web3) {\n    const balance = await web3.eth.getBalance(loginUser);\n    return web3.utils.fromWei(balance);\n  }\n\n  ;\n  return 0;\n};\nexport const convertToBN = number => {\n  return Web3.utils.toBN(number);\n};","map":{"version":3,"sources":["/Users/lehoa/icetea/work/redkite/frontend-user/src/services/web3.ts"],"names":["Web3","ConnectorNames","connectorsByName","ETH_CHAIN_ID","NETWORK_AVAILABLE","POOL_ABI","require","NETWORK_URL","process","env","REACT_APP_NETWORK_URL","BSC_NETWORK_URL","REACT_APP_BSC_RPC_URL","MAX_INT","SmartContractMethod","getWeb3Instance","windowObj","window","ethereum","web3","isMetaMask","currentProvider","isMetaMaskInstalled","getProviderByNetwork","networkName","appChainID","typeMethod","forceUsingEther","providers","HttpProvider","Read","provider","getContractInstance","ABIContract","contractAddress","MetaMask","web3Instance","eth","Contract","getContractInstanceWeb3","isEth","getPoolContract","networkAvailable","poolHash","BSC","ETH","getContractInstanceWithEthereum","getContractInstanceWithBSC","convertFromWei","value","unit","utils","fromWei","convertToWei","toWei","isValidAddress","address","isAddress","getETHBalance","loginUser","balance","getBalance","convertToBN","number","toBN"],"mappings":"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","sourcesContent":["import Web3 from 'web3';\nimport WalletLink from \"walletlink\";\nimport { connectorNames, ConnectorNames, connectorsByName } from '../constants/connectors';\nimport { ETH_CHAIN_ID } from '../constants/network';\nimport {NETWORK_AVAILABLE} from \"../constants\";\n\nconst POOL_ABI = require('../abi/Pool.json');\n\nconst NETWORK_URL = process.env.REACT_APP_NETWORK_URL || \"\";\nconst BSC_NETWORK_URL = process.env.REACT_APP_BSC_RPC_URL || \"\";\nexport const MAX_INT = '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n\nexport enum SmartContractMethod {\n  Write = \"Write\",\n  Read = \"Read\"\n}\n\ntype smartContractMethod = Extract<SmartContractMethod, SmartContractMethod.Write | SmartContractMethod.Read>\n\nexport const getWeb3Instance = () => {\n  const windowObj = window as any;\n  const { ethereum, web3 } = windowObj;\n  if (ethereum && ethereum.isMetaMask) {\n    return new Web3(ethereum);\n  }\n  if (web3) {\n    return new Web3(web3.currentProvider);\n  }\n  return null;\n};\n\nexport const isMetaMaskInstalled = () => {\n  const windowObj = window as any;\n  const { ethereum } = windowObj;\n  return ethereum && ethereum.isMetaMask;\n};\n\n\nexport const getProviderByNetwork = (\n  networkName: connectorNames,\n  appChainID: string,\n  typeMethod: smartContractMethod,\n  forceUsingEther: boolean\n) => {\n  if (forceUsingEther) {\n      return new Web3.providers.HttpProvider(NETWORK_URL);\n  }\n\n  if (appChainID && typeMethod === SmartContractMethod.Read) {\n      return new Web3.providers.HttpProvider(appChainID === ETH_CHAIN_ID ? NETWORK_URL: BSC_NETWORK_URL);\n  }\n\n  const provider = (connectorsByName[networkName as connectorNames] as any);\n  return provider;\n}\n\nexport const getContractInstance =\n  (ABIContract: any,\n   contractAddress: string,\n   networkName: connectorNames = ConnectorNames.MetaMask,\n   appChainID: string = ETH_CHAIN_ID as string,\n   typeMethod: smartContractMethod = SmartContractMethod.Read,\n   forceUsingEther: boolean = false\n  ) => {\n  const provider = getProviderByNetwork(networkName as connectorNames, appChainID, typeMethod, forceUsingEther);\n\n  if (provider) {\n    const web3Instance = new Web3(provider);\n\n    return new web3Instance.eth.Contract(\n      ABIContract,\n      contractAddress,\n    );\n  }\n\n  return;\n};\n\nexport const getContractInstanceWeb3 = (isEth = true) => {\n  let provider = new Web3.providers.HttpProvider(NETWORK_URL);\n  if (!isEth) {\n    provider = new Web3.providers.HttpProvider(BSC_NETWORK_URL);\n  }\n  let web3Instance = new Web3(provider);\n  return web3Instance;\n};\n\nexport const getPoolContract = ({ networkAvailable, poolHash }: any) => {\n  if (networkAvailable == NETWORK_AVAILABLE.BSC) {\n    const web3Instance = getContractInstanceWeb3(false);\n    return new web3Instance.eth.Contract(POOL_ABI, poolHash);\n  } else if (networkAvailable == NETWORK_AVAILABLE.ETH) {\n    const web3Instance = getContractInstanceWeb3(true);\n    return new web3Instance.eth.Contract(POOL_ABI, poolHash);\n  } else {\n    return null;\n  }\n};\n\nexport const getContractInstanceWithEthereum = (ABIContract: any, contractAddress: string) => {\n  const windowObj = window as any;\n  const { ethereum } = windowObj;\n  if (ethereum && ethereum.isMetaMask) {\n    const web3Instance = new Web3(ethereum);\n    return new web3Instance.eth.Contract(ABIContract, contractAddress);\n  } else if (windowObj.web3) {\n    const web3Instance = new Web3(windowObj.web3.currentProvider);\n    return new web3Instance.eth.Contract(ABIContract, contractAddress);\n  } else {\n    return null;\n  }\n};\n\nexport const getContractInstanceWithBSC = (ABIContract: any, contractAddress: string) => {\n  const windowObj = window as any;\n  const { ethereum } = windowObj;\n  const web3Instance = new Web3(ethereum);\n  return new web3Instance.eth.Contract(ABIContract, contractAddress);\n};\n\nexport const convertFromWei = (value: any, unit = 'ether') => {\n  return Web3.utils.fromWei(value);\n};\n\nexport const convertToWei = (value: any, unit = 'ether') => {\n  // const webInstance = getWeb3Instance();\n  // // @ts-ignore\n  // return webInstance.utils.toWei(value, unit);\n  return Web3.utils.toWei(value);\n};\n\nexport const isValidAddress = (address: string) => {\n  return Web3.utils.isAddress(address);\n}\n\nexport const getETHBalance = async (loginUser: string) => {\n  const web3 = getWeb3Instance() as any;\n  if (web3) {\n    const balance = await web3.eth.getBalance(loginUser);\n\n    return web3.utils.fromWei(balance);\n  };\n\n  return 0;\n}\n\nexport const convertToBN = (number: string) => {\n  return Web3.utils.toBN(number)\n}\n"]},"metadata":{},"sourceType":"module"}