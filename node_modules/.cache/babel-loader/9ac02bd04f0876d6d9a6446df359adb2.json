{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useCallback } from 'react';\nimport { ethers } from 'ethers';\nimport BigNumber from 'bignumber.js';\nimport { useTypedSelector } from '../../../hooks/useTypedSelector';\nimport { getContractInstance, SmartContractMethod } from '../../../services/web3';\nimport Pool_ABI from '../../../abi/Pool.json';\nconst DECIMAL_PLACES = 8;\n\nconst useTokenSold = (tokenDetails, poolAddress, ableToFetchFromBlockchain) => {\n  _s();\n\n  const [tokenSold, setTokenSold] = useState();\n  const [tokenSoldLoading, setTokenSoldLoading] = useState(false);\n  const {\n    appChainID\n  } = useTypedSelector(state => state.appNetwork).data;\n  const connector = useTypedSelector(state => state.connector).data;\n  const retrieveTokenSold = useCallback(async poolAddress => {\n    try {\n      if (poolAddress && tokenDetails && ableToFetchFromBlockchain && ethers.utils.isAddress(poolAddress)) {\n        setTokenSoldLoading(true);\n        const contract = getContractInstance(Pool_ABI, poolAddress, connector, appChainID, SmartContractMethod.Read);\n\n        if (contract) {\n          let tokenSold = await contract.methods.tokenSold().call();\n          tokenSold = new BigNumber(tokenSold).div(new BigNumber(10).pow(18)).toFixed(DECIMAL_PLACES);\n          setTokenSold(tokenSold);\n          return tokenSold;\n        }\n\n        return 0;\n      }\n    } catch (err) {\n      console.log(err.message);\n    }\n  }, [appChainID, connector, poolAddress, ableToFetchFromBlockchain]);\n\n  if (ableToFetchFromBlockchain && poolAddress && !tokenSoldLoading) {\n    retrieveTokenSold(poolAddress || '');\n  }\n\n  return {\n    tokenSoldLoading,\n    tokenSold,\n    retrieveTokenSold\n  };\n};\n\n_s(useTokenSold, \"ki44QkOmv7no5O9vKkmmlg0PDNw=\", false, function () {\n  return [useTypedSelector, useTypedSelector];\n});\n\nexport default useTokenSold;","map":{"version":3,"sources":["/Users/lehoa/icetea/work/redkite/frontend-user/src/pages/BuyToken/hooks/useTokenSold.ts"],"names":["useState","useCallback","ethers","BigNumber","useTypedSelector","getContractInstance","SmartContractMethod","Pool_ABI","DECIMAL_PLACES","useTokenSold","tokenDetails","poolAddress","ableToFetchFromBlockchain","tokenSold","setTokenSold","tokenSoldLoading","setTokenSoldLoading","appChainID","state","appNetwork","data","connector","retrieveTokenSold","utils","isAddress","contract","Read","methods","call","div","pow","toFixed","err","console","log","message"],"mappings":";;AAAA,SAASA,QAAT,EAAmBC,WAAnB,QAAsC,OAAtC;AACA,SAASC,MAAT,QAAuB,QAAvB;AACA,OAAOC,SAAP,MAAsB,cAAtB;AAGA,SAASC,gBAAT,QAAiC,iCAAjC;AACA,SAAQC,mBAAR,EAA6BC,mBAA7B,QAAwD,wBAAxD;AACA,OAAOC,QAAP,MAAqB,wBAArB;AAEA,MAAMC,cAAc,GAAG,CAAvB;;AAEA,MAAMC,YAAY,GAAG,CACnBC,YADmB,EAEnBC,WAFmB,EAGnBC,yBAHmB,KAIhB;AAAA;;AACH,QAAM,CAACC,SAAD,EAAYC,YAAZ,IAA4Bd,QAAQ,EAA1C;AACA,QAAM,CAACe,gBAAD,EAAmBC,mBAAnB,IAA0ChB,QAAQ,CAAU,KAAV,CAAxD;AACA,QAAM;AAAEiB,IAAAA;AAAF,MAAiBb,gBAAgB,CAACc,KAAK,IAAKA,KAAK,CAACC,UAAjB,CAAhB,CAA6CC,IAApE;AACA,QAAMC,SAAS,GAAIjB,gBAAgB,CAACc,KAAK,IAAIA,KAAK,CAACG,SAAhB,CAAhB,CAA2CD,IAA9D;AAEA,QAAME,iBAAiB,GAAGrB,WAAW,CAAC,MAAOU,WAAP,IAA+B;AACnE,QAAI;AACF,UAAIA,WAAW,IAAID,YAAf,IAA+BE,yBAA/B,IACGV,MAAM,CAACqB,KAAP,CAAaC,SAAb,CAAuBb,WAAvB,CADP,EAEK;AACAK,QAAAA,mBAAmB,CAAC,IAAD,CAAnB;AACA,cAAMS,QAAQ,GAAGpB,mBAAmB,CAACE,QAAD,EAAWI,WAAX,EAAwBU,SAAxB,EAAmCJ,UAAnC,EAA+CX,mBAAmB,CAACoB,IAAnE,CAApC;;AACA,YAAID,QAAJ,EAAc;AACZ,cAAIZ,SAAS,GAAG,MAAMY,QAAQ,CAACE,OAAT,CAAiBd,SAAjB,GAA6Be,IAA7B,EAAtB;AACAf,UAAAA,SAAS,GAAG,IAAIV,SAAJ,CAAcU,SAAd,EAAyBgB,GAAzB,CAA6B,IAAI1B,SAAJ,CAAc,EAAd,EAAkB2B,GAAlB,CAAsB,EAAtB,CAA7B,EAAwDC,OAAxD,CAAgEvB,cAAhE,CAAZ;AACAM,UAAAA,YAAY,CAACD,SAAD,CAAZ;AACA,iBAAOA,SAAP;AACD;;AACD,eAAO,CAAP;AACD;AACL,KAdD,CAcE,OAAOmB,GAAP,EAAY;AACZC,MAAAA,OAAO,CAACC,GAAR,CAAYF,GAAG,CAACG,OAAhB;AACD;AACF,GAlBoC,EAkBlC,CAAClB,UAAD,EAAaI,SAAb,EAAwBV,WAAxB,EAAqCC,yBAArC,CAlBkC,CAArC;;AAoBA,MAAIA,yBAAyB,IAAID,WAA7B,IAA4C,CAACI,gBAAjD,EAAmE;AACjEO,IAAAA,iBAAiB,CAACX,WAAW,IAAI,EAAhB,CAAjB;AACD;;AAED,SAAO;AACLI,IAAAA,gBADK;AAELF,IAAAA,SAFK;AAGLS,IAAAA;AAHK,GAAP;AAKD,CAvCD;;GAAMb,Y;UAOmBL,gB,EACJA,gB;;;AAiCrB,eAAeK,YAAf","sourcesContent":["import { useState, useCallback } from 'react';\nimport { ethers } from 'ethers';\nimport BigNumber from 'bignumber.js';\n\nimport { TokenType } from '../../../hooks/useTokenDetails';\nimport { useTypedSelector } from '../../../hooks/useTypedSelector';\nimport{ getContractInstance, SmartContractMethod } from '../../../services/web3';\nimport Pool_ABI from '../../../abi/Pool.json';\n\nconst DECIMAL_PLACES = 8;\n\nconst useTokenSold = (\n  tokenDetails: TokenType | undefined,\n  poolAddress: string | undefined,\n  ableToFetchFromBlockchain: boolean | undefined\n) => {\n  const [tokenSold, setTokenSold] = useState<any>();\n  const [tokenSoldLoading, setTokenSoldLoading] = useState<boolean>(false);\n  const { appChainID } = useTypedSelector(state  => state.appNetwork).data;\n  const connector  = useTypedSelector(state => state.connector).data;\n\n  const retrieveTokenSold = useCallback(async (poolAddress: string) => {\n    try {\n      if (poolAddress && tokenDetails && ableToFetchFromBlockchain\n          && ethers.utils.isAddress(poolAddress)\n         ) {\n           setTokenSoldLoading(true);\n           const contract = getContractInstance(Pool_ABI, poolAddress, connector, appChainID, SmartContractMethod.Read);\n           if (contract) {\n             let tokenSold = await contract.methods.tokenSold().call();\n             tokenSold = new BigNumber(tokenSold).div(new BigNumber(10).pow(18)).toFixed(DECIMAL_PLACES);\n             setTokenSold(tokenSold);\n             return tokenSold;\n           }\n           return 0;\n         }\n    } catch (err) {\n      console.log(err.message);\n    }\n  }, [appChainID, connector, poolAddress, ableToFetchFromBlockchain]);\n\n  if (ableToFetchFromBlockchain && poolAddress && !tokenSoldLoading) {\n    retrieveTokenSold(poolAddress || '');\n  }\n\n  return {\n    tokenSoldLoading,\n    tokenSold,\n    retrieveTokenSold\n  }\n};\n\nexport default useTokenSold;\n"]},"metadata":{},"sourceType":"module"}