{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useCallback } from 'react';\nimport { ethers } from 'ethers';\nimport { useWeb3React } from '@web3-react/core';\nimport { useDispatch } from 'react-redux';\nimport { TRANSACTION_ERROR_MESSAGE } from '../constants/alert';\nimport { MAX_INT } from '../services/web3';\nimport { alertSuccess, alertFailure } from '../store/actions/alert';\nimport { getContract } from '../utils/contract';\nimport ERC20_ABI from '../abi/Erc20.json';\n\nconst useTokenAllowance = (token, owner, spender, sotaABI) => {\n  _s();\n\n  const [tokenApproveLoading, setTokenApproveLoading] = useState(false);\n  const [transactionHash, setTransactionHash] = useState(\"\");\n  const dispatch = useDispatch();\n  const {\n    library,\n    account\n  } = useWeb3React();\n  const approveToken = useCallback(async () => {\n    setTransactionHash(\"\");\n\n    try {\n      if (token && spender && owner && ethers.utils.isAddress(owner) && ethers.utils.isAddress(spender) && ethers.utils.isAddress(token.address)) {\n        setTokenApproveLoading(true);\n        const contract = getContract(token.address, ERC20_ABI, library, account);\n\n        if (contract) {\n          // let overrides = fixGasLimitWithProvider(library, 'approve');\n          // const transaction = await contract.approve(spender, MAX_INT, overrides);\n          const transaction = await contract.approve(spender, MAX_INT);\n          console.log('Approve Token', transaction);\n          setTransactionHash(transaction.hash);\n          await transaction.wait(1);\n          dispatch(alertSuccess(\"Token Approve Successful!\"));\n          setTokenApproveLoading(false);\n        }\n      }\n    } catch (err) {\n      console.log('[ERROR] - useTokenAllowance:', err);\n      dispatch(alertFailure(TRANSACTION_ERROR_MESSAGE));\n      setTokenApproveLoading(false);\n      throw new Error(err.message);\n    }\n  }, [owner, spender, token]);\n  return {\n    tokenApproveLoading,\n    approveToken,\n    setTokenApproveLoading,\n    transactionHash\n  };\n};\n\n_s(useTokenAllowance, \"YoCMbhg0BmV79F6fEqN5l9puIYQ=\", false, function () {\n  return [useDispatch, useWeb3React];\n});\n\nexport default useTokenAllowance;","map":{"version":3,"sources":["/Users/lehoa/icetea/work/redkite/frontend-user/src/hooks/useTokenApprove.ts"],"names":["useState","useCallback","ethers","useWeb3React","useDispatch","TRANSACTION_ERROR_MESSAGE","MAX_INT","alertSuccess","alertFailure","getContract","ERC20_ABI","useTokenAllowance","token","owner","spender","sotaABI","tokenApproveLoading","setTokenApproveLoading","transactionHash","setTransactionHash","dispatch","library","account","approveToken","utils","isAddress","address","contract","transaction","approve","console","log","hash","wait","err","Error","message"],"mappings":";;AAAA,SAASA,QAAT,EAAmBC,WAAnB,QAAsC,OAAtC;AACA,SAASC,MAAT,QAAuB,QAAvB;AACA,SAASC,YAAT,QAA6B,kBAA7B;AACA,SAASC,WAAT,QAA4B,aAA5B;AAEA,SAASC,yBAAT,QAA0C,oBAA1C;AACA,SAASC,OAAT,QAAwB,kBAAxB;AACA,SAASC,YAAT,EAAuBC,YAAvB,QAA2C,wBAA3C;AACA,SAASC,WAAT,QAA4B,mBAA5B;AAGA,OAAOC,SAAP,MAAsB,mBAAtB;;AAGA,MAAMC,iBAAiB,GAAG,CACxBC,KADwB,EAExBC,KAFwB,EAGxBC,OAHwB,EAIxBC,OAJwB,KAKrB;AAAA;;AACH,QAAM,CAACC,mBAAD,EAAsBC,sBAAtB,IAAgDjB,QAAQ,CAAU,KAAV,CAA9D;AACA,QAAM,CAACkB,eAAD,EAAkBC,kBAAlB,IAAwCnB,QAAQ,CAAC,EAAD,CAAtD;AACA,QAAMoB,QAAQ,GAAGhB,WAAW,EAA5B;AAEA,QAAM;AAAEiB,IAAAA,OAAF;AAAWC,IAAAA;AAAX,MAAuBnB,YAAY,EAAzC;AAEE,QAAMoB,YAAY,GAAGtB,WAAW,CAAC,YAAY;AAC3CkB,IAAAA,kBAAkB,CAAC,EAAD,CAAlB;;AAEA,QAAI;AACF,UAAIP,KAAK,IAAIE,OAAT,IAAoBD,KAApB,IACGX,MAAM,CAACsB,KAAP,CAAaC,SAAb,CAAuBZ,KAAvB,CADH,IAEGX,MAAM,CAACsB,KAAP,CAAaC,SAAb,CAAuBX,OAAvB,CAFH,IAGGZ,MAAM,CAACsB,KAAP,CAAaC,SAAb,CAAuBb,KAAK,CAACc,OAA7B,CAHP,EAIK;AACAT,QAAAA,sBAAsB,CAAC,IAAD,CAAtB;AAEA,cAAMU,QAAQ,GAAGlB,WAAW,CAACG,KAAK,CAACc,OAAP,EAAgBhB,SAAhB,EAA2BW,OAA3B,EAAoCC,OAApC,CAA5B;;AAEA,YAAIK,QAAJ,EAAc;AACZ;AACA;AACA,gBAAMC,WAAW,GAAG,MAAMD,QAAQ,CAACE,OAAT,CAAiBf,OAAjB,EAA0BR,OAA1B,CAA1B;AACAwB,UAAAA,OAAO,CAACC,GAAR,CAAY,eAAZ,EAA6BH,WAA7B;AAEDT,UAAAA,kBAAkB,CAACS,WAAW,CAACI,IAAb,CAAlB;AAEC,gBAAMJ,WAAW,CAACK,IAAZ,CAAiB,CAAjB,CAAN;AAEDb,UAAAA,QAAQ,CAACb,YAAY,CAAC,2BAAD,CAAb,CAAR;AACCU,UAAAA,sBAAsB,CAAC,KAAD,CAAtB;AACD;AACF;AACL,KAxBD,CAwBE,OAAOiB,GAAP,EAAY;AACZJ,MAAAA,OAAO,CAACC,GAAR,CAAY,8BAAZ,EAA4CG,GAA5C;AACAd,MAAAA,QAAQ,CAACZ,YAAY,CAACH,yBAAD,CAAb,CAAR;AACAY,MAAAA,sBAAsB,CAAC,KAAD,CAAtB;AACA,YAAM,IAAIkB,KAAJ,CAAUD,GAAG,CAACE,OAAd,CAAN;AACD;AACJ,GAjCiC,EAiC/B,CAACvB,KAAD,EAAQC,OAAR,EAAiBF,KAAjB,CAjC+B,CAAhC;AAmCF,SAAO;AACLI,IAAAA,mBADK;AAELO,IAAAA,YAFK;AAGLN,IAAAA,sBAHK;AAILC,IAAAA;AAJK,GAAP;AAMD,CArDD;;GAAMP,iB;UAQaP,W,EAEYD,Y;;;AA6C/B,eAAeQ,iBAAf","sourcesContent":["import { useState, useCallback } from 'react';\nimport { ethers } from 'ethers';\nimport { useWeb3React } from '@web3-react/core';\nimport { useDispatch } from 'react-redux';\n\nimport { TRANSACTION_ERROR_MESSAGE } from '../constants/alert';\nimport { MAX_INT } from '../services/web3';\nimport { alertSuccess, alertFailure } from '../store/actions/alert';\nimport { getContract } from '../utils/contract';\nimport { TokenType } from '../hooks/useTokenDetails';\n\nimport ERC20_ABI from '../abi/Erc20.json';\nimport {fixGasLimitWithProvider} from \"../utils\";\n\nconst useTokenAllowance = (\n  token: TokenType | undefined,\n  owner: string | null | undefined,\n  spender: string | null | undefined,\n  sotaABI: false\n) => {\n  const [tokenApproveLoading, setTokenApproveLoading] = useState<boolean>(false);\n  const [transactionHash, setTransactionHash] = useState(\"\");\n  const dispatch = useDispatch();\n\n  const { library, account } = useWeb3React();\n\n    const approveToken = useCallback(async () => {\n      setTransactionHash(\"\");\n\n      try {\n        if (token && spender && owner\n            && ethers.utils.isAddress(owner)\n            && ethers.utils.isAddress(spender)\n            && ethers.utils.isAddress(token.address)\n           ) {\n             setTokenApproveLoading(true);\n\n             const contract = getContract(token.address, ERC20_ABI, library, account as string);\n\n             if (contract) {\n               // let overrides = fixGasLimitWithProvider(library, 'approve');\n               // const transaction = await contract.approve(spender, MAX_INT, overrides);\n               const transaction = await contract.approve(spender, MAX_INT);\n               console.log('Approve Token', transaction);\n\n              setTransactionHash(transaction.hash);\n\n               await transaction.wait(1);\n\n              dispatch(alertSuccess(\"Token Approve Successful!\"));\n               setTokenApproveLoading(false);\n             }\n           }\n      } catch (err) {\n        console.log('[ERROR] - useTokenAllowance:', err);\n        dispatch(alertFailure(TRANSACTION_ERROR_MESSAGE));\n        setTokenApproveLoading(false);\n        throw new Error(err.message);\n      }\n  }, [owner, spender, token]);\n\n  return {\n    tokenApproveLoading,\n    approveToken,\n    setTokenApproveLoading,\n    transactionHash\n  }\n}\n\nexport default useTokenAllowance;\n"]},"metadata":{},"sourceType":"module"}