{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useCallback } from 'react';\nimport { ethers } from 'ethers';\nimport BigNumber from 'bignumber.js';\nimport { useTypedSelector } from '../../../hooks/useTypedSelector';\nimport { getContractInstance, SmartContractMethod } from '../../../services/web3';\nimport Pool_ABI from '../../../abi/PreSalePool.json';\n\nconst useUserRemainTokensClaim = (tokenDetails, poolAddress, ableToFetchFromBlockchain) => {\n  _s();\n\n  const [userPurchasedLoading, setUserPurchasedLoading] = useState(false);\n  const {\n    appChainID\n  } = useTypedSelector(state => state.appNetwork).data;\n  const connector = useTypedSelector(state => state.connector).data;\n  const retrieveClaimableTokens = useCallback(async (userAddress, poolAddress) => {\n    try {\n      if (userAddress && poolAddress && tokenDetails && ableToFetchFromBlockchain && ethers.utils.isAddress(userAddress) && ethers.utils.isAddress(poolAddress)) {\n        setUserPurchasedLoading(true);\n        const contract = getContractInstance(Pool_ABI, poolAddress, connector, appChainID, SmartContractMethod.Read);\n\n        if (contract) {\n          const userPurchased = await contract.methods.userPurchased(userAddress).call();\n          console.log('userPurchased===>', userPurchased);\n          const userClaimed = await contract.methods.userClaimed(userAddress).call();\n          const userPurchasedReturn = new BigNumber(userPurchased).minus(new BigNumber(userClaimed)).div(new BigNumber(10).pow(tokenDetails.decimals)).toFixed();\n          return {\n            userPurchased: new BigNumber(userPurchased).div(new BigNumber(10).pow(tokenDetails.decimals)).toFixed(),\n            userClaimed: new BigNumber(userClaimed).div(new BigNumber(10).pow(tokenDetails.decimals)).toFixed(),\n            userPurchasedReturn\n          };\n        }\n\n        return {\n          userPurchased: 0,\n          userClaimed: 0,\n          userPurchasedReturn: 0,\n          tokenDecimals: tokenDetails.decimals\n        };\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  }, [appChainID, connector, poolAddress, ableToFetchFromBlockchain]);\n  return {\n    userPurchasedLoading,\n    retrieveClaimableTokens\n  };\n};\n\n_s(useUserRemainTokensClaim, \"2dGPgw9cPcsuP+jkkQl+iew4+Bg=\", false, function () {\n  return [useTypedSelector, useTypedSelector];\n});\n\nexport default useUserRemainTokensClaim;","map":{"version":3,"sources":["/Users/lehoa/icetea/work/redkite/frontend-user/src/pages/BuyToken/hooks/useUserRemainTokensClaim.ts"],"names":["useState","useCallback","ethers","BigNumber","useTypedSelector","getContractInstance","SmartContractMethod","Pool_ABI","useUserRemainTokensClaim","tokenDetails","poolAddress","ableToFetchFromBlockchain","userPurchasedLoading","setUserPurchasedLoading","appChainID","state","appNetwork","data","connector","retrieveClaimableTokens","userAddress","utils","isAddress","contract","Read","userPurchased","methods","call","console","log","userClaimed","userPurchasedReturn","minus","div","pow","decimals","toFixed","tokenDecimals","err"],"mappings":"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","sourcesContent":["import { useState, useCallback } from 'react';\nimport { ethers } from 'ethers';\nimport BigNumber from 'bignumber.js';\n\nimport { TokenType } from '../../../hooks/useTokenDetails';\nimport { useTypedSelector } from '../../../hooks/useTypedSelector';\nimport{ getContractInstance, SmartContractMethod } from '../../../services/web3';\nimport Pool_ABI from '../../../abi/PreSalePool.json';\n\nconst useUserRemainTokensClaim = (\n  tokenDetails: TokenType | undefined,\n  poolAddress: string | undefined,\n  ableToFetchFromBlockchain: boolean | undefined\n) => {\n  const [userPurchasedLoading, setUserPurchasedLoading] = useState<boolean>(false);\n\n  const { appChainID } = useTypedSelector(state  => state.appNetwork).data;\n  const connector  = useTypedSelector(state => state.connector).data;\n\n  const retrieveClaimableTokens = useCallback(async (userAddress: string, poolAddress: string) => {\n    try {\n      if (userAddress && poolAddress && tokenDetails && ableToFetchFromBlockchain\n          && ethers.utils.isAddress(userAddress)\n          && ethers.utils.isAddress(poolAddress)\n      ) {\n        setUserPurchasedLoading(true);\n        const contract = getContractInstance(Pool_ABI, poolAddress, connector, appChainID, SmartContractMethod.Read);\n        if (contract) {\n          const userPurchased = await contract.methods.userPurchased(userAddress).call();\n\n          console.log('userPurchased===>', userPurchased);\n\n          const userClaimed = await contract.methods.userClaimed(userAddress).call();\n          const userPurchasedReturn = new BigNumber(userPurchased).minus(new BigNumber(userClaimed)).div(new BigNumber(10).pow(tokenDetails.decimals)).toFixed();\n\n          return {\n            userPurchased: new BigNumber(userPurchased).div(new BigNumber(10).pow(tokenDetails.decimals)).toFixed(),\n            userClaimed: new BigNumber(userClaimed).div(new BigNumber(10).pow(tokenDetails.decimals)).toFixed(),\n            userPurchasedReturn,\n          }\n        }\n        return {\n          userPurchased: 0,\n          userClaimed: 0,\n          userPurchasedReturn: 0,\n          tokenDecimals: tokenDetails.decimals,\n        }\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  }, [appChainID, connector, poolAddress, ableToFetchFromBlockchain]);\n\n  return {\n    userPurchasedLoading,\n    retrieveClaimableTokens\n  }\n}\n\nexport default useUserRemainTokensClaim;\n"]},"metadata":{},"sourceType":"module"}